import{_ as p,M as l,p as c,q as i,R as n,t as s,N as e,V as t,a1 as o}from"./framework-3f81730e.js";const r={},u=o(`<h1 id="dart-api-参考" tabindex="-1"><a class="header-anchor" href="#dart-api-参考" aria-hidden="true">#</a> Dart API 参考</h1><h2 id="河图类" tabindex="-1"><a class="header-anchor" href="#河图类" aria-hidden="true">#</a> 河图类</h2><p>Hetu 是一个集合了多个不同的编程语言工具（sourceContext, lexicon, parser, bundler, analyzer, compiler and interpreter）的默认实现的工具类。对于普通用户，可以直接创建一个 Hetu 对象，然后就可以开始使用脚本功能了。下面介绍的一些函数接口，实际上分别定义在 compiler 或者 interpreter 上，但我们可以通过 Hetu 类来方便的统一访问。</p><h3 id="init" tabindex="-1"><a class="header-anchor" href="#init" aria-hidden="true">#</a> init()</h3><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  bool useDefaultModuleAndBinding <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token class-name">HTLocale</span><span class="token operator">?</span> locale<span class="token punctuation">,</span>
  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token punctuation">&gt;</span></span> externalFunctions <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">HTExternalFunctionTypedef</span><span class="token punctuation">&gt;</span></span> externalFunctionTypedef <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HTExternalClass</span><span class="token punctuation">&gt;</span></span> externalClasses <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HTExternalTypeReflection</span><span class="token punctuation">&gt;</span></span> externalTypeReflections <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法会初始化河图脚本内置的一些 Dart 类的绑定。用户也可以向这个方法传入参数来同时初始化一些自定义绑定。</p><ul><li><p><strong>externalFunctions</strong>: 载入一些 Dart 函数，用以在脚本中调用。效果等同于在 <strong>init()</strong> 执行完毕后，手动调用 <strong>bindExternalFunction()</strong>.</p></li><li><p><strong>externalFunctionTypedef</strong>: 载入一些 Dart 的函数定义，以及对应的解绑函数。之后可以便捷的将一个脚本函数解析为 Dart 函数，以用于 Dart 的对象的构造函数等需要 Dart Lambda 的场合。。效果等同于在 <strong>init()</strong> 执行完毕后，手动调用 <strong>bindExternalFunctionType</strong>.</p></li><li><p><strong>externalClasses</strong>: 载入一些 Dart 类的绑定定义。之后可以在脚本中直接获得一个 Dart 对象，或者调用某个 Dart 对象的函数。 效果等同于在 <strong>init()</strong> 执行完毕后，手动调用 <strong>bindExternalClass</strong>.</p></li></ul><h3 id="eval-evalfile" tabindex="-1"><a class="header-anchor" href="#eval-evalfile" aria-hidden="true">#</a> eval(), evalFile()</h3><p>解释一个字符串形式的代码文件。使用这个方法会在内部经历完整的 parse, analyze, compile 的过程，最终以字节码形式保存在内存中。后续调用以字节码形式执行。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">dynamic</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token class-name">String</span> content<span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token class-name">String</span><span class="token operator">?</span> fileName<span class="token punctuation">,</span>
    <span class="token class-name">String</span><span class="token operator">?</span> moduleName<span class="token punctuation">,</span>
    bool globallyImport <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token class-name">HTResourceType</span> type <span class="token operator">=</span> <span class="token class-name">HTResourceType</span><span class="token punctuation">.</span>hetuLiteralCode<span class="token punctuation">,</span>
    <span class="token class-name">String</span><span class="token operator">?</span> invokeFunc<span class="token punctuation">,</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">dynamic</span><span class="token punctuation">&gt;</span></span> positionalArgs <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">&gt;</span></span> namedArgs <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HTType</span><span class="token punctuation">&gt;</span></span> typeArgs <span class="token operator">=</span> <span class="token keyword">const</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),d=n("li",null,[n("strong",null,"content"),s(": Dart 字符串形式的代码文件内容。")],-1),k=n("li",null,[n("strong",null,"fileName"),s(": 文件名。如果其他代码文件使用了 import，将会参考这个名字。如果忽略，将会以字符串的头部内容加上 Hash 生成。")],-1),m=n("li",null,[n("strong",null,"moduleName"),s(": 模块名。整个代码文件编译后的字节码整体称作一个模块。")],-1),g=n("li",null,[n("strong",null,"globallyImport"),s(": 是否将这个模块的内容直接导入到全局命名空间。这样做可以让其他模块以后无需导入即可使用这个代码文件的内容。")],-1),v=n("strong",null,"type",-1),h=n("strong",null,"代码文件类型",-1),_=n("li",null,[n("strong",null,"invokeFunc"),s(": 在解析完毕后，直接执行这个代码文件中的一个函数。函数的参数用 "),n("strong",null,"positionalArgs"),s(" 和 "),n("strong",null,"namedArgs"),s(" 传递。效果等同于在 "),n("strong",null,"eval()"),s(" 执行过后，再手动调用 "),n("strong",null,"invoke()"),s("。")],-1),b=n("h3",{id:"compile-compilefile-loadbytecode",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#compile-compilefile-loadbytecode","aria-hidden":"true"},"#"),s(" compile(), compileFile(), loadBytecode()")],-1),f=n("p",null,[s("这一对方法可以用于需要更高运行效率的场合。"),n("strong",null,"compile()"),s(" 将一个代码文件编码为字节码。随后可以在另外的场合获取这段字节码然后调用 "),n("strong",null,"loadBytecode()"),s(" 执行。在执行时，将无需再进行 parse, analyze, compile 的过程。")],-1),y=n("strong",null,"命令行工具",-1),x=o(`<h3 id="invoke" tabindex="-1"><a class="header-anchor" href="#invoke" aria-hidden="true">#</a> invoke()</h3><p>在解释器对象上用这个方法来调用某个代码文件中定义的函数。类似的，也有一些其他的调用存在与脚本的 <strong>HTClass</strong>，<strong>HTInstance</strong>, <strong>HTFunction</strong> 等对象上。如果你将这些脚本中的对象直接传回了 Dart 代码，就可以使用这个接口来调用脚本函数。</p><h2 id="代码空间" tabindex="-1"><a class="header-anchor" href="#代码空间" aria-hidden="true">#</a> 代码空间</h2><p><strong>HTResourceContext</strong> 是解释器保存和管理代码文件的抽象工具类。如果你安装了 <strong>hetu_script_dev_tools</strong> 或者 <strong>hetu_script_flutter</strong>，将会有各自对应的代码空间类的具体实现来管理你磁盘上，或者 Flutter 程序中的资源文件。默认情况下的代码空间实现是 <strong>HTOverlayContext</strong> ，这个实现不会主动读取文件，而需要通过下面这些接口来手动保存和更新代码文件：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">void</span> <span class="token function">addResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> fullName<span class="token punctuation">,</span> <span class="token class-name">HTSource</span> resource<span class="token punctuation">)</span>

<span class="token keyword">void</span> <span class="token function">removeResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> fullName<span class="token punctuation">)</span>

<span class="token keyword">void</span> <span class="token function">updateResource</span><span class="token punctuation">(</span><span class="token class-name">String</span> fullName<span class="token punctuation">,</span> <span class="token class-name">HTSource</span> resource<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5);function T(H,w){const a=l("RouterLink");return c(),i("div",null,[u,n("ul",null,[d,k,m,g,n("li",null,[v,s(": "),e(a,{to:"/zh-Hans/guide/package/#%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B"},{default:t(()=>[h]),_:1}),s("。决定了解释器的行为模式")]),_]),b,f,n("p",null,[s("可以参考 hetu_script_dev_tools 包提供的"),e(a,{to:"/zh-Hans/guide/command_line_tool/#compile"},{default:t(()=>[y]),_:1}),s("中附带的编译功能。")]),x])}const F=p(r,[["render",T],["__file","D:/_dev/hetu-script/docs/docs/.vuepress/.temp/pages/zh-Hans/api_reference/dart/index.html.vue"]]);export{F as default};
