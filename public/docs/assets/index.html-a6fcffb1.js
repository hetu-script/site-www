import{_ as t,M as e,p,q as o,R as c,t as n,N as i,V as l,a1 as s}from"./framework-5866ffd3.js";const r={},u=s('<h1 id="代码的模块化" tabindex="-1"><a class="header-anchor" href="#代码的模块化" aria-hidden="true">#</a> 代码的模块化</h1><h2 id="代码文件的导入" tabindex="-1"><a class="header-anchor" href="#代码文件的导入" aria-hidden="true">#</a> 代码文件的导入</h2><p>代码文件可以使用 import 声明导入其他代码文件，解释器会提前将代码导入的其他文件解释并保存在内存中。</p><h2 id="单一字节码模块" tabindex="-1"><a class="header-anchor" href="#单一字节码模块" aria-hidden="true">#</a> 单一字节码模块</h2><p>可以使用 compile() 方法将一段代码编译成一个单一字节码文件。在编译时，编译器会自动将代码中使用 <strong>import</strong> 语句导入的所有其他代码文件一并编译，这样在再分发时只需要发布单一的字节码模块即可。</p><h2 id="资源空间" tabindex="-1"><a class="header-anchor" href="#资源空间" aria-hidden="true">#</a> 资源空间</h2><p>资源空间（HTResourceContext）是一个抽象接口，指编译器获取代码文件的辅助类。默认的资源空间的实现是 <strong>HTOverlayContext</strong>。这个实现不会自动读取任何资源。用户需要提前手动添加代码文件，才可以让 import 语句生效。</p><h2 id="资源类型" tabindex="-1"><a class="header-anchor" href="#资源类型" aria-hidden="true">#</a> 资源类型</h2><p>资源类型（ResourceType）决定了解释器如何看待代码以及如何看待 import 语句引入的文件。在解释器的 <strong>eval()</strong> 方法中包含这个参数。</p><ul><li><p>当省略掉 eval() 方法的 <strong>ResourceType type</strong> 参数时，解释器会以字面量的形式解释字符串（<strong>ResourceType.hetuLiteralCode</strong>）。这种类型的代码不会生成自己的命名空间，而是直接使用全局命名空间。</p></li><li><p>当 eval() 方法的代码类型参数为 <strong>ResourceType.hetuScript</strong> 时，解释器会使用类似 Javascript, Python 和 Lua 那样的形式来解释。除了声明语句之外，代码中可以直接执行表达式语句，例如在代码顶层直接调用某个函数。这种类型的代码会使用单独的命名空间。执行这种代码的效果类似于执行一个匿名函数。代码中的变量的初始化值会被立即运算。代码按照书写的顺序执行。</p></li><li><p>当 eval() 方法的代码类型参数为 <strong>ResourceType.hetuModule</strong> 时，解释器会使用类似 C++, Java 和 Dart 那样的 APP 的形式来解释。代码中只允许包含导入导出语句，以及声明语句。代码中的变量的初始化值在调用时才会被计算出来。代码的执行顺序也并不一定是书写顺序。可以通过传入 invoke 参数来立即调用一个函数。但不要求这个函数一定是 &#39;main&#39; 函数。</p></li></ul><p>对于解释器的 <strong>evalFile()</strong> 方法，代码文件类型将以文件名后缀作为判断基准：&#39;*.hts&#39; 对应了 <strong>ResourceType.hetuScript</strong>，而 &#39;*.ht&#39; 对应了 <strong>ResourceType.hetuModule</strong>。</p><h2 id="导入字节码文件" tabindex="-1"><a class="header-anchor" href="#导入字节码文件" aria-hidden="true">#</a> 导入字节码文件</h2>',12),d=s(`<p>在脚本代码文件中导入前，你需要通过解释器上的 <strong>loadBytecode()</strong> 方法来载入这个文件。下面是一个例子：</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;dart:io&#39;</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:hetu_script/hetu_script.dart&#39;</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:hetu_script_dev_tools/hetu_script_dev_tools.dart&#39;</span></span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> sourceContext <span class="token operator">=</span> <span class="token class-name">HTFileSystemResourceContext</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;example/script/&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> hetu <span class="token operator">=</span> <span class="token class-name">Hetu</span><span class="token punctuation">(</span>sourceContext<span class="token punctuation">:</span> sourceContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  hetu<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> binaryFile <span class="token operator">=</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;example/script/module.out&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> bytes <span class="token operator">=</span> binaryFile<span class="token punctuation">.</span><span class="token function">readAsBytesSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hetu<span class="token punctuation">.</span><span class="token function">loadBytecode</span><span class="token punctuation">(</span>bytes<span class="token punctuation">:</span> bytes<span class="token punctuation">,</span> module<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;calculate&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hetu<span class="token punctuation">.</span><span class="token function">evalFile</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;import_binary_module.hts&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后你可以在代码中使用 import 加上 &#39;module:&#39; 开头的路径来导入它。注意，出于错误检查的目的，此时你<strong>必须</strong>为引入的 module 提供一个命名空间别名。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;module:calculate&#39;</span></span> <span class="token operator">as</span> calculate<span class="token punctuation">;</span>

<span class="token keyword">final</span> result <span class="token operator">=</span> calculate<span class="token punctuation">.</span><span class="token function">calculate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="导入-json-文件" tabindex="-1"><a class="header-anchor" href="#导入-json-文件" aria-hidden="true">#</a> 导入 JSON 文件</h2><p>和 Javascript 一样，河图中的对象字面量语法和 JSON 完全兼容，因此你可以直接导入一个 JSON 文件，而无需进行任何类型转换。</p><p>河图提供的 ResourceContext 会默认载入 json 和 json5 类型的文件作为代码文件。</p><div class="language-dart line-numbers-mode" data-ext="dart"><pre class="language-dart"><code><span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:hetu_script/hetu_script.dart&#39;</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string-literal"><span class="token string">&#39;package:hetu_script_dev_tools/hetu_script_dev_tools.dart&#39;</span></span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> sourceContext <span class="token operator">=</span> <span class="token class-name">HTFileSystemResourceContext</span><span class="token punctuation">(</span>root<span class="token punctuation">:</span> <span class="token string-literal"><span class="token string">&#39;example/script&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> hetu <span class="token operator">=</span> <span class="token class-name">Hetu</span><span class="token punctuation">(</span>sourceContext<span class="token punctuation">:</span> sourceContext<span class="token punctuation">)</span><span class="token punctuation">;</span>
  hetu<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  hetu<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&#39;&#39;&#39;
    import &#39;values.json&#39; as json
    print(json.name) // use json value like a struct
  &#39;&#39;&#39;</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，json 资源文件并非代码文件，没有命名空间，因此在导入时必须指定一个别名才可以使用。</p>`,9);function k(v,m){const a=e("RouterLink");return p(),o("div",null,[u,c("p",null,[n("一个已经编译成了"),i(a,{to:"/zh-Hans/guide/command_line_tool/#compile"},{default:l(()=>[n("字节码文件")]),_:1}),n("的模块也可以被导入。但只能以整个模块导入，其作为入口代码的文件指定了你可以导入的内容。使用这种单一字节码文件可以提交一些效率，因为这样解释器无需进行 parse, analyze, compile 的过程。")]),d])}const g=t(r,[["render",k],["__file","index.html.vue"]]);export{g as default};
